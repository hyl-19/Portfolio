# Algorithm Analysis Projects

This document summarizes a collection of algorithmic challenges and their Python implementations, showcasing problem-solving techniques across search, dynamic programming, graph theory, and image processing.

---

## A-1

1. **Binary Tree Reconstruction & Secret Code**

   * Rebuilt a binary tree from preorder and inorder traversals.
   * Generated postorder traversal to decode secret messages.
   * Key skills: recursion, tree traversal.

2. **Hamiltonian Cycle Finder**

   * Implemented backtracking to locate a Hamiltonian cycle starting at a fixed vertex in undirected graphs.
   * Demonstrated efficient pruning and recursion.
   * Key skills: DFS, cycle detection, combinatorial search.

3. **Water Jug Puzzle Solver**

   * Simulated jug operations (fill, empty, pour) to reach a target volume.
   * Employed breadth-first search on state-space.
   * Key skills: BFS, state representation.

4. **Connected Component Labeling**

   * Labeled 4-connected components in binary images and calculated their areas.
   * Utilized union-find or two-pass scanning.
   * Key skills: image scanning, disjoint-set data structures.

5. **15-Puzzle Solver**

   * Solved the classic 15-puzzle using A\* search with Manhattan distance heuristic.
   * Output minimum move count and move sequence.
   * Key skills: heuristic search, priority queues, puzzle state encoding.

---

## A-2

1. **Longest Increasing Subsequence (LIS)**

   * Found the LIS in integer sequences using dynamic programming and binary search optimization.
   * Reported both length and actual subsequence.
   * Key skills: DP, patience sorting.

2. **0-1 Knapsack Problem**

   * Implemented DP to maximize value under weight constraints.
   * Reconstructed selected item indices.
   * Key skills: DP table construction, backtracking.

3. **Huffman Coding**

   * Built Huffman trees from character frequencies.
   * Generated prefix codes and performed encoding/decoding of binary strings.
   * Key skills: greedy algorithms, priority queues, tree structures.

4. **Single-Source Shortest Paths (Dijkstra)**

   * Computed minimum distances from a source vertex in weighted directed graphs.
   * Used min-heap (priority queue) for efficiency.
   * Key skills: graph representation, Dijkstra’s algorithm.

5. **Maze Shortest Path Visualization**

   * Processed 500×500 black & white maze images to find and overlay the shortest path.
   * Employed BFS for pathfinding and OpenCV for image manipulation.
   * Key skills: image processing, BFS, path reconstruction.

---

## Highlights

* **Search Strategies:** BFS, DFS, A\* heuristic search.
* **Dynamic Programming:** Classic DP problems (LIS, knapsack).
* **Graph Algorithms:** Dijkstra, Hamiltonian path search.
* **Greedy Techniques:** Huffman coding.
* **Image Processing:** Component labeling, maze solving with OpenCV.

---

These projects demonstrate a strong grasp of algorithm design, data structures, and practical problem-solving in Python.
